using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DataStructures
{
    internal class Array_LinearList
    {
        // 배열은 초기화 할때 정한 크기가 변할지 않는 자료구조이다.
        // 그 이유는 배열의 인덱스와 요소의 접근하는 방법에 있는데
        // 배열은 데이터를 일렬로 저장해서 첫번째 인덱스를 통해 다른 나머지의
        // 인덱스들의 위치도 알 수 있도록 하기 때문이다.
        // 따라서 배열의 시간 복잡도를 Big-O로 표현하면
        // 요소에 접근은
        // 원하는 인덱스에 배열의 자료형 크기를 곱해서 첫번째 인덱스(0)에 더하는 방식이므로
        // O(1)
        // 요소의 탐색은
        // 배열의 인덱스 마다 대조해봐야 하므로 배열의 크기인(n)
        // (참고로 배열은 인덱스가 요소의 크기 순서대로 정렬되있지 않기 떄문에 이분법을 사용하는 건 불가능 하다.)
        // O(n) 이다.

        // 선형 리스트는
        // 쉽게 설명하면 처음에 커다란 배열을 만들고 해당 배열에서 실제로 사용중인 인덱스의 수를 카운팅 하는 방식으로 이루어진다.
        // 따라서 시간 복잡도를 Big-O로 표현하면
        // 요소에 접근은 배열과 동일하기 때문에
        // O(1)
        // 요소의 탐색또한
        // 인덱스 마다 대조해봐야 하므로 n
        // 배열과 동일하지만 다른점은 n이 배열의 크기(허용량)이 아닌 실 사용량을 의미한다는 것
        // O(N)
        // 요소의 삽입은 (insert가 아닌 add인 경우를 말한다.)
        // 커다란 배열에 접근해서 요소를 변경시키는 것이므로 B(1)이 나오지만
        // 사용량이 허용량을 초과하려고 하면 기존에 사용하던 것보다 크기가 더 큰 배열을 생성해서
        // 요소들을 복사해오고 기존 배열을 버리는 방식이고
        // Big-O 표기법은 가장 높은 차수의 계수와 나머지 모든 항을 제거하고 표기하는 규칙이므로
        // O(N)이 된다.
        // 또한 요소의 삭제는
        // 배열의 데이터를 연속해서 저장해야 한다는 특징 때문에
        // 해당 요소의 인덱스 다음에 위치한 요소들을 복사해서 해당 인덱스에 덮어씌우는 방식을 사용해서
        // 마찬가지로 O(N)이 된다.
    }
}
