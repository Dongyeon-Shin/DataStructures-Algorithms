using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Lab2
{
    internal class SortingAlgorithm
    {
        /*
         * -선형정렬 알고리즘 (Linear Sorting Algorithm)
         * 
         * 1. 선택 정렬 (Selection Sort)
         * 배열의 모든 요소를 앞에서부터 하나씩 줄여가며 탐색해서 최솟값을 계속 맨 앞의 요소와 변경하는 방식으로
         * 정렬시키는 알고리즘
         * 
         * 자신이 보유한 요소의 개수만큼 탐색하는 걸 요소의 개수만큼 반복하므로 O(n²)의 시간복잡도를 가진다.
         * 
         * 2. 삽입 정렬 (Insertion Sort)
         * 배열의 앞에서부터 차례대로 요소를 확인하며 직전의 요소의 값과 비교해서 값이 같거나 더 클때까지
         * 해당 요소와 서로 순서를 바꾸도록 하는 방식으로 정렬시키는 알고리즘
         * 
         * 운이 좋으면 (이미 정렬되어 있던 경우) 모든 요소를 한번씩만 탐색하는 (O(n))으로 정렬이 끝나지만
         * 배열이 거꾸로 정렬되어 있는 최악의 경우 요소마다 전체 요소의 개수만큼 위치를 바꿔야 하므로
         * 선택정렬과 마찬가지로 O(n²)의 시간복잡도를 가진다.
         * 
         * 3. 버블 정렬 (Bubble Sort)
         * 배열에 있는 요소의 개수 n번만큼 모든 요소의 값을 탐색해서 연속된 요소의 값을 비교해
         * 더 작은 요소가 앞으로 오도록 순서를 바꿔주는 방식으로 배열을 정렬한다.
         * 이때 한 바퀴를 돌때마다 마지막 요소에는 가장 값이 큰 요소가 저장되므로
         * 선택 정렬과는 반대로 뒤에서부터 탐색 요소를 하나씩 줄여가며 정렬하는 알고리즘
         * 
         * O(n²)의 시간 복잡도를 가진다.
         * 
         * 
         * 
         * -분할정복정렬 알고리즘 (Divide and Conquer Algorithm)
         * 1. 합병 정렬 (Merge Sort)
         * 배열을 반으로 쪼개는 과정을 요소가 하나씩 남을때까지 반복한다.
         * 다 쪼개졌으면 이제 차례차례 배열을 다시 하나로 합치는 과정을 시작하는데
         * 이때 왼쪽과 오른쪽 배열의 요소의 값을 비교해서 값이 더 적은 순서대로
         * 배열에 병합시키는 방식으로 정렬하는 알고리즘
         * 
         * 이진 트리 방식이 사용되었기 때문에 O(nlog₂n)의 시간복잡도를 가진다.
         * 또한 값이 같은 요소는 기본적으로 기존의 순서대로 정렬되는 안정적인 정렬방식이다.
         * 
         * 그러나 해당 방법을 사용하기 위해선 임시 배열을 생성해야 해서 다른 정렬방식보다 메모리에 부담이 간다.
         * 링크드 리스트를 사용하면 부담을 줄일 수 있지만 C#은 가비지 컬랙터의 존재로 주객전도의 상황이
         * 벌어질 수 있기때문에 불가능하다.
         * 
         * 2. 퀵 정렬 (Quick Sort)
         * 배열 안에 있는 요소 중 하나를 pivot으로 설정한다.
         * pivot을 기준으로 pivot보다 값이 작으면 pivot의 왼쪽 크면 pivot의 오른쪽으로 이동한다.
         * 각각 왼쪽과 오른쪽에 있는 요소들도 각자 pivot을 선정해서 해당 행위를 반복한다.
         * 
         * Pivot이 배열 내 요소중 가장 크거나 작은 값일 경우 모든 요소를 요소의 개수만큼 반복해야 하므로
         * O(n²)의 시간 복잡도를 가진다.
         * 그러나 평균적으로는 O(nlog₂n)의 시간복잡도를 가지고 내부 루프가 굉장히 효율적으로 작동하도록
         * 설계되어 있고 매 단계에서 적어도 1개의 요소가 자기 자리를 찾아 이후 정렬해야하는 개수를 줄여
         * 일반적으로 퀵 정렬이 다른 합병 정렬 같은 O(nlog₂n)의 시간복잡도를 가진 알고리즘보다 훨씬 빠르게 동작한다.
         * 
         * 하지만 합병 정렬과 다르게 퀵정렬은 같은 값을 가진 요소의 순서가 기존 순서와 다르게 바뀔 수 있는
         * 불안정한 정렬방식이라는 특징을 가진다.
         * 
         * 
         * -
         * 힙 정렬 (Heap Sort)
         * 배열을 완전이진 트리 형태로 구성하고 최소 힙 자료구조 형태(가장 값이 작은 노드부터 자신보다
         * 큰 값을 가진 두 개의 자식 노드를 가지는 형태)로 만든다. 그리고 가장 위의 요소(가장 값이 작은 요소)를
         * 가장 밑에 있는 요소와 자리를 바꾼뒤 다시 힙 구조로 재배열하는 것을 반복해서 배열을 정렬한다.
         * (내림차순의 경우 최대 힙 자료구조 형태를 사용한다.)
         * 
         * 완전이진 트리를 사용했으므로 O(nlog₂n)의 시간복잡도를 가진다.
         * 
         * 이론상으로는 항상 O(nlog₂n)의 시간복잡도를 가진 좋은 알고리즘이지만 코드 외부적으로
         * 컴퓨터 cpu가 연속적으로 저장되어 있는 데이터, 예를 들면 인덱스로 접근 가능한 자료구조들의 요소를 불러올때는
         * 해당 요소 하나만 골라 가져오는 것이 아니라 캐시 메모리(Cache Memory)에 해당 요소의 주변 요소들까지 저장해놓고
         * 캐시 메모리에서 해당 요소를 꺼내서 사용하는 것이다.
         * cpu가 캐시 메모리 내의 테이터를 읽는 것은 메인 메모리에서 읽어오는 것보다 큰 속도의 이점을 가진다.
         * 그러나 힙 정렬 처럼 데이터가 비연속적으로 저장되어 있으면 해당 이점을 누릴 수 없다는 단점이 있어
         * 실제 속도가 퀵 정렬에 비해 밀린다.
         * 
         * 또한 힙 정렬은 퀵 정렬과 마찬가지로 불안정한 정렬방식이라는 특징을 공유한다.
         */
    }
}
